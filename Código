/*
23143
Paulina Martínez
Electrónica digital 2
Sección 10
Laboratorio #3
*/

//Librerías para el código
#include <Arduino.h>
#include <stdint.h>
//Librería para PWM
#include <driver/ledc.h>
//Librería para el servo
#include <ESP32Servo.h>

//Definición de leds
#define LED_V 27
#define LED_R 26
#define LED_A 12

//Definición de botones (todos pull down)
#define botonled 21 //escoge que led modificar
#define botonbrillo 18 //determina el brillo del led
#define botonright 17 //mover servo a la derecha
#define botonleft 4 //mover servo a la izquierda

//Variables para hacer cambios de leds 
typedef enum color {rojo=0, verde, azul, todo} color;
volatile color colorActual = rojo;

//Variables para modificar el brillo de cada led
volatile uint8_t brillo_V=0;
volatile uint8_t brillo_R=0;
volatile uint8_t brillo_A=0;

//Configuración del PWM: channels
#define pwmChannel_V 0
#define pwmChannel_R 1
#define pwmChannel_A 2

//Configuración del PWM:frecuencia
#define freqpwm 50

//Configuración del PWM: resolución
#define respwm 10

//Prototipo de función para configurar el PWM
void initPWM_V();
void initPWM_R();
void initPWM_A();

//Prototipo de funciones para botones con ISR
void initbotonled();
void initbotonbrillo();
void initbotonleft();
void initbotonright();
void IRAM_ATTR botonled_ISR();
void IRAM_ATTR botonbrillo_ISR();
void IRAM_ATTR botonleft_ISR();
void IRAM_ATTR botonright_ISR();

//Prototipo de funciones para actualizar los estados de los leds
void actualizarpwm();

//Variables para antirrebote de los botones que va a estar en el ISR
const long tiempo = 100;
volatile uint32_t lastb1 = 0;
volatile uint32_t lastb2 = 0;
volatile uint32_t lastb3 = 0;
volatile uint32_t lastb4 = 0;
bool estadob1 = LOW;
bool estadob2 = LOW;
bool estadob3 = LOW;
bool estadob4 = LOW;
bool lecturab1;
bool lecturab2;
bool lecturab3;
bool lecturab4;

void setup() {
  //Inicio de comunicación serial
  Serial.begin(115200);

  //Definición de los pines de botones
  pinMode(botonled, INPUT_PULLDOWN);
  pinMode(botonbrillo, INPUT_PULLDOWN);
  pinMode(botonright, INPUT_PULLDOWN);
  pinMode(botonleft, INPUT_PULLDOWN);

  //Definición de los pines de leds
  pinMode(LED_V, OUTPUT);
  pinMode(LED_R, OUTPUT);
  pinMode(LED_A, OUTPUT);

  //Configuración del PWM
  initPWM_A();
  initPWM_R();
  initPWM_V();

  //Configuración de interrupción para botones
  initbotonled();
  initbotonbrillo();
  initbotonleft();
  initbotonright();

void loop() {
  //Actualización de los leds
  actualizarpwm();

//Funciones para el PWM
void initPWM_A(){
  ledcSetup(pwmChannel_A, freqpwm, respwm);
  ledcAttachPin(LED_A, pwmChannel_A);
  //ledcWrite(pwmChannel_A, 0);
}


void initPWM_R(){
  ledcSetup(pwmChannel_R, freqpwm, respwm);
  ledcAttachPin(LED_R, pwmChannel_R);
  //ledcWrite(pwmChannel_R, 0);
}


void initPWM_V(){
  ledcSetup(pwmChannel_V, freqpwm, respwm);
  ledcAttachPin(LED_V, pwmChannel_V);
  //ledcWrite(pwmChannel_V, 0);
}

//Lectura de botones con el ISR
void initbotonled() {
  attachInterrupt(digitalPinToInterrupt(botonled), botonled_ISR, RISING); //rising porque es pull down
}

void initbotonbrillo() {
  attachInterrupt(digitalPinToInterrupt(botonbrillo), botonbrillo_ISR, RISING); //rising porque es pull down
}

void initbotonright() {
  attachInterrupt(digitalPinToInterrupt(botonright), botonright_ISR, RISING); //rising porque es pull down
}

void initbotonleft() {
  attachInterrupt(digitalPinToInterrupt(botonleft), botonleft_ISR, RISING); //rising porque es pull down
}

//ISR botones para leds
void IRAM_ATTR botonled_ISR() {
  uint32_t tiempoactual = millis();
  if (tiempoactual - lastb3 > tiempo) {
    colorActual=(color)((colorActual+1)%3);
    lastb3=tiempoactual;
}
}

void IRAM_ATTR botonbrillo_ISR() {
  uint32_t tiempoactual2 = millis();
  if (tiempoactual2 - lastb4 > tiempo) {
    switch(colorActual){
      case rojo: brillo_R=(brillo_R+1)%5;
      break;
      case verde: brillo_V=(brillo_V+1)%5;
      break;
      case azul: brillo_A=(brillo_A+1)%5;
      break;
    }
    lastb4=tiempoactual2;
}
}

void actualizarpwm(){
  //Esto nos calcula el valor máximo del duty cycle dependiendo de la resolución
  const uint32_t MAX_DUTY = (1u << respwm) - 1u; //Aquí es de 2^10-1, porque ese valor tiene respwm, escala este valor usando -1
  //Divide esto en 4 niveles, entonces convierte el brillo proporcionalmente
  uint32_t dutyA = (brillo_A * MAX_DUTY) / 4; //brillo = 0 equivale al duty = 0
  uint32_t dutyR = (brillo_R * MAX_DUTY) / 4; //brillo =4 equivale al duty = 2^10-1
  uint32_t dutyV = (brillo_V * MAX_DUTY) / 4;
  //Se indica a que channel qué hacer, implementando el duty a cada uno
  ledcWrite(pwmChannel_A, dutyA);
  ledcWrite(pwmChannel_R, dutyR);
  ledcWrite(pwmChannel_V, dutyV);
}
